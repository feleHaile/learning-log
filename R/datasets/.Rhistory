library(sparklyr)
devtools::install_github("rstudio/sparklyr")
install.packages('backports')
library(backports)
devtools::install_github("rstudio/sparklyr")
library(sparklyr)
Sys.setenv(SPARK_HOME='C:/Program Files (x86)/spark-2.0.2-bin-hadoop2.7')
.libPaths(c(file.path(Sys.getenv('SPARK_HOME'), 'R', 'lib'), .libPaths()))
library(SparkR, lib.loc = c(file.path(Sys.getenv("SPARK_HOME"), "R", "lib")))
sc <- sparkR.init(master="local")
sparkR.session(master = "local[*]", sparkConfig = list(spark.driver.memory = "2g"))
library(rJava)
sparkR.session(master = "local[*]", sparkConfig = list(spark.driver.memory = "2g"))
library(ggvis)     # for interactivity purposes
library(grid)      # for annotation purposes
library(gridExtra) # for annotation purposes
setwd("C:\\Users\\JYESOH\\Desktop\\GIT\\useful.scripts\\R")
library(ggplot2)
setwd("C:\\Users\\JYESOH\\Desktop\\GIT\\useful.scripts\\R\\datasets")
library(ggmap)      # extends ggplot2 for maps
library(rgdal)      # spatial data
library(rgeos)      # vector data
library(maptools)   # mapping functions
library(plyr)       # processing data
library(tidyr)      # processing data
library(tmap)       # creating maps
lnd <- readOGR(dsn = "map", layer = "london_sport")
head(lnd@data, n = 2)
mean(lnd$Partic_Per)
london = gUnaryUnion(lnd, lnd$dummy)
london = SpatialPolygonsDataFrame(london, data.frame(dummy = c("london")), match.ID = FALSE)   ## adding dataframe
## centroid of london
centrelondon = gCentroid(london, byid = TRUE)
# coordinates for start and end
c1 = c(centrelondon$x, centrelondon$x)
c2 = c(90, -90)
c3 = c(90, -90)
c4 = c(centrelondon$y,centrelondon$y)
# using line strings
L1 = Line(cbind(c1, c2))
L2 = Line(cbind(c3, c4))
# create lines
Ln1 = Lines(list(L1), ID = "a")
Ln2 = Lines(list(L2), ID = "b")
# convert the lines into SpatialLines
Ls1 <- SpatialLines(LinesList = list(Ln1))
Ls2 <- SpatialLines(LinesList = list(Ln2))
# convert into SpatialLinesDataFrame
Longitude = SpatialLinesDataFrame(Ls1, data.frame(Z = c("1", "2"), row.names = c("a","b")))
Latitude = SpatialLinesDataFrame(Ls2, data.frame(Z = c("1", "2"), row.names = c("a","b")))
east <- coordinates(lnd)[,1] > Longitude@lines[[1]]@Lines[[1]]@coords[,1][1]
north <- coordinates(lnd)[,2] > Latitude@lines[[1]]@Lines[[1]]@coords[,2][1]
lnd@data$quadrant[east & north] <- "northeast"
summary(lnd)
lnd@data
plot(lnd)
plot(Longitude)
Line(cbind(c1, c2))
SpatialLinesDataFrame(Ls1, data.frame(Z = c("1", "2"), row.names = c("a","b")))
plot(east)
plot(lnd)
plot(lnd[east & north,],add = TRUE, col = "red" )
plot(lnd[west & north,],add = TRUE, col = "blue" )
plot(lnd[west & north,],add = TRUE, col = "blue" )
east <- coordinates(lnd)[,1] > Longitude@lines[[1]]@Lines[[1]]@coords[,1][1]
north <- coordinates(lnd)[,2] > Latitude@lines[[1]]@Lines[[1]]@coords[,2][1]
west <- coordinates(lnd)[,1] < Longitude@lines[[1]]@Lines[[1]]@coords[,1][1]
south <-coordinates(lnd)[,2] < Latitude@lines[[1]]@Lines[[1]]@coords[,2][1]
lnd@data$quadrant[east & north] <- "northeast"
lnd@data$quadrant[west & north] <- "northwest"
lnd@data$quadrant[east & south] <- "southeast"
lnd@data$quadrant[west & south] <- "southwest"
plot(lnd[east & north,],add = TRUE, col = "red" )
plot(lnd[west & north,],add = TRUE, col = "blue" )
plot(lnd[east & south,],add = TRUE, col = "green" )
plot(lnd[west & south,],add = TRUE, col = "yellow" )
llgridlines(lnd, lty= 3, side ="EN", offset = -0.5)
east
north
lnd[east & north,],add = TRUE
lnd[east & north,]
lnd[east & north,]$data
lnd[east & north,]@data
llgridlines(lnd, lty= 3, side ="EN")         # plotting grid lines
dev.off()
plot(lnd[east & north,],add = TRUE, col = "red" )
plot(lnd)
plot(lnd[east & north,],add = TRUE, col = "red" )
plot(lnd[west & north,],add = TRUE, col = "blue" )
plot(lnd[east & south,],add = TRUE, col = "green" )
plot(lnd[west & south,],add = TRUE, col = "yellow" )
llgridlines(lnd, lty= 3, side ="EN")         # plotting grid lines
Longitude@lines[[1]]@Lines[[1]]@coords[,1][1]
Longitude@lines[[1]]@Lines[[1]]@coords[,1]
Longitude@lines[[1]]@Lines[[1]]@coords
vec <- vector(mode = "numeric", length = 3)
df <- data.frame(x = 1:3, y = c(1/2, 2/3, 3/4))
class(vec)
class(df)
mat <- as.matrix(df)                                        # create matrix object with as.matrix
sp1 <- SpatialPoints(coords = mat)
sp1 <- SpatialPoints(coords = mat)
class(sp1)
spdf <- SpatialPointsDataFrame(sp1, data = df)
class(spdf)
proj4string(lnd) <- NA_character_ # remove CRS information from lnd
proj4string(lnd) <- CRS("+init=epsg:27700") # assign a new CRS
proj4string(lnd) <- NA_character_ # remove CRS information from lnd
proj4string(lnd) <- CRS("+init=epsg:27700") # assign a new CRS
EPSG <- make_EPSG() # create data frame of available EPSG codes
EPSG[grepl("WGS 84$", EPSG$note), ] # search for WGS 84 code
epsg
EPSG
lnd84 <- spTransform(lnd, CRS("+init=epsg:4326")) # reproject
saveRDS(object = lnd84, file = "data/lnd84.Rds")
saveRDS(object = lnd84, file = "map\\lnd84.Rds")
rm(lnd84)
coordinates(lnd)
lnd84
lnd84
library(rgdal)
lnd <- readOGR(dsn = "data", "london_sport")
lnd <- readOGR(dsn = "map", "london_sport")
plot(lnd)
nrow(lnd)
crime_data <- read.csv("map\\mps-recordedcrime-borough.csv",
stringsAsFactors = FALSE)
head(crime_data, 3) # display first 3 lines
head(crime_data$CrimeType) # information about crime type
crime_theft <- crime_data[crime_data$CrimeType == "Theft & Handling", ]
head(crime_theft, 2) # take a look at the result (replace 2 with 10 to see more rows)
crime_ag <- aggregate(CrimeCount ~ Borough, FUN = sum, data = crime_theft)
head(crime_ag, 2)
head(crime_ag, 2)
crime_ag
lnd$name %in% crime_ag$Borough
lnd$name
lnd$name[!lnd$name %in% crime_ag$Borough]
crime_ag$Borough[!crime_ag$Borough %in% lnd$name]
lnd$name[!lnd$name %in% crime_ag$Borough]
lnd
names(crime_ag)
crime_ag[crime_ag$Borough == NULL & CrimeCount < 4000]
crime_ag[crime_ag$Borough == NULL & crime_ag$CrimeCount < 4000]
crime_ag$Borough == NULL & crime_ag$CrimeCount < 4000
crime_ag$Borough == NULL
names(crime_ag)
crime_ag$Borough == 'NULL'
crime_ag[crime_ag$Borough == 'NULL; & crime_ag$CrimeCount < 4000]
crime_ag[crime_ag$Borough == 'NULL' & crime_ag$CrimeCount < 4000]
crime_ag[crime_ag$Borough == 'NULL' & crime_ag$CrimeCount < 4000]
crime_ag$Borough == 'NULL' & crime_ag$CrimeCount < 4000
crime_ag$Borough == 'NULL'
crime_ag[crime_ag$Borough == 'NULL' & crime_ag$CrimeCount < 4000,]
library(dplyr)
head(lnd$name)
head(crime_ag$Borough)
crime_ag <- rename(crime_ag, name = Borough)
lnd@data <- left_join(lnd@data, crime_ag)
library(tmap)
qtm(lnd, "CrimeCount") # plot the basic map
library(rgdal)
stations <- readOGR(dsn = "data", layer = "lnd-stns")
stations <- readOGR(dsn = "maps", layer = "lnd-stns")
stations <- readOGR(dsn = "map", layer = "lnd-stns")
proj4string(stations) # this is the full geographical detail.
proj4string(lnd) # what's the coordinate reference system (CRS)
bbox(stations) # the extent, 'bounding box' of stations
bbox(lnd) # return the bounding box of the lnd object
lnd@data
qtm(lnd, "Pop_2001")
qtm(lnd, "Partic_Per")
stations27700 <- spTransform(stations, CRSobj = CRS(proj4string(lnd)))
stations <- stations27700 # overwrite the stations object
rm(stations27700) # remove the stations27700 object to clear up
plot(lnd) # plot London for context (see Figure 9)
points(stations) # overlay the station points
stations_backup <- stations # backup the stations object
stations <- stations_backup[lnd, ]
plot(stations) # test the clip succeeded (see Figure 10)
sel <- over(stations_backup, lnd)
stations2 <- stations_backup[!is.na(sel[,1]),]
